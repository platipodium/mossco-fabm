#include "fabm_driver.h"
!#ifdef _FABM_F2003_
! --------------------------------------------
! Size- & distribution based ctenophore model
! kai wirtz Apr 2014
! --------------------------------------------
module hzg_jelly
!
! !USES:
  use fabm_types
  use fabm_driver
  implicit none

 !public flags for communication with fabm-driver/time-loop
  !character(len=80),   public      ::  jelly_timestr
  !integer,             public      ::  OutJellyRGR, CalcJellyRGR
  public grazkinetics

  private
 ! HZG model types
  !type type_diff
  ! real(rk) :: mu, dmudl, d2mudl2, dmudV, dsinkdl, dsinkdp, d2mudl2_d, dmu_d
  !end type
  integer   :: numb=1
  real(rk)  :: i13sig
  real(rk)  :: relC, fC
!#SP0
!!----------------------------------------------------------------------
!! this code is generated by a parser  (conv_nml_fabm.c by kai wirtz)
!!----------------------------------------------------------------------
! --- HZG model types
type type_jelly_var
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det,ParasPp,ParasBe,BenTime
 real(rk) :: Cop,Temp,Phy
end type
type type_jelly_rhs
 real(rk) :: B_Pp,l_Pp,B_Be,l_Be,B_Det,ParasPp,ParasBe,BenTime
end type
! standard fabm model types
type,extends(type_base_model),public :: type_hzg_jelly
type (type_state_variable_id)        :: id_B_Pp,id_l_Pp,id_B_Be,id_l_Be,id_B_Det,id_ParasPp,id_ParasBe,id_BenTime
type (type_dependency_id)            :: id_Cop
type (type_dependency_id)            :: id_Temp
type (type_dependency_id)            :: id_Phy
type (type_diagnostic_variable_id)   :: id_prod_Be, id_Mort_Be, id_fA_Be, id_Imax_Be, id_lopt_Be, id_prod_Pp, id_Mort_Pp, id_fA_Pp, id_Imax_Pp, id_mort_P, id_mort_S, id_mort_R, id_mort_G, id_mort_J, id_mort_T, id_somgrowth, id_recruit, id_paras_dl, id_som_dl, id_turb_dl, id_init_dl, id_graz_dl, id_sen_dl, id_prod_dl, id_resp_dl, id_dl_prey, id_dl_pred, id_al_Im, id_mixBmass, id_mixlsize, id_Tdep
real(rk) ::  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial, ParasPp_initial, ParasBe_initial, BenTime_initial
real(rk) ::  lA, l0, lstarv, sigma, Imax_pot, yield, mR, mS, mP, mT, Q10, Tc, Bcrit, relCVDens, m_predBe, loptA_Pp, loptA_Be, immigr, rDet, rParasite, fTDmort, m_pcap, mDisturb, deltaT, deltaCop
logical  ::  TransectOn, SizeDynOn, LowPassOn, OptionOn, TEcophysOn

contains
!   Model procedures
procedure :: initialize
procedure :: do
end type type_hzg_jelly

!
! !PRIVATE DATA MEMBERS:
 real(rk), parameter :: secs_pr_day = 86400.0_rk
!EOP
!!--------------------------------------------------------------------

contains
!> @brief initializes the model
!! @details here the maecs namelists are read and assigned respectively in the model type (self),
!! state & diagnostic variables are registered in FABM and dependencies are imported from FABM
!>
!> **Model parameters, descriptions and corresponding symbols used in formulas:**
! initial values
!> \describepar{TransectOn   ,    , mixing between coastal transect boxes, .false. }
!> \describepar{SizeDynOn    ,     , life stage cycling enabled, .true. }
!> \describepar{LowPassOn    ,     , filter high frequency in forcing, .true. }
!> \describepar{OptionOn     ,      , generic, .false. }
!> \describepar{TEcophysOn   ,    , size dependency in mortality,  }
! other parameters
!> \describepar{lA           , \ell_A           , adult ctenophore size        , 2.0 log(ESD/mm)}
!> \describepar{l0           , \ell_0           , offspring size, -1.2 log(ESD/mm)}
!> \describepar{lstarv       , \ell_S       , minimum starvation size, 2. log(ESD/mm)}
!> \describepar{sigma        , \sigma'        , log-size specific std deviation , 1. log(ESD/mm)^2}
!> \describepar{Imax_pot     , I_\mathrm{max}^*     , maximum ingestion rate for ideal consumer, prey, T, and food , 173. 1/d}
!> \describepar{yield        , y_0        , assimilation efficiency, 0.4 }
!> \describepar{mR           , m_R^0           , temperature dependent, natural mortality rate , 0.02 1/d}
!> \describepar{mS           , m_S^0           , physiological mortality under senescence , 3.E-2 1/d}
!> \describepar{mP           , m_P^0           , density dependent mortality rate (parasites), 1.6E-5 1/d.µg-C/L}
!> \describepar{mT           , m_{T}^0           , mortality due to physical damage (turbulence) 0.028, 0. 1/d}
!> \describepar{Q10          , Q_{10}          , rate increase at 10C temperature rise, 2. }
!> \describepar{Tc           , ^o$C] $T_c           , critical threshold temperature, 4.5 $^o$C}
!> \describepar{Bcrit        , B^*        , minimal prey biomass (Holling-III) , 25. µg-C/L}
!> \describepar{relCVDens    , R_\rho    , C-biovolume density ratio non-gelatinous/gelatinous plankton, 120.0 µg-C/L}
!> \describepar{m_predBe     , m_\mathrm{top}     , loss rate of Beroe due to top-predator , 0. 1/d}
!> \describepar{loptA_Pp     , \lcsize_\mathrm{opt,Pp}^A     , optimal prey size adult P.pileus , -0.6 }
!> \describepar{loptA_Be     , \lcsize_\mathrm{opt,Be}^A     , optimal prey size adult Beroe , 2. }
!> \describepar{immigr       , \epsilon_\mathrm{in}       , migration mass inflow rate , 5e-06 µg-C/L.d}
!> \describepar{rDet         , r_\mathrm{Det}         , detritus turnover rate , 0.05 1/d}
!> \describepar{rParasite    , r_\mathrm{Pars}    , turnover parasite dynamics, 1. }
!> \describepar{fTDmort      , f_0      , warm temperature detritus ''feed-back''   , 0.5 }
!> \describepar{m_pcap       ,        , dependency of parasite dynamics on host/detritus biomass, 25. }
!> \describepar{mDisturb     , B_\mathrm{cd}     , critical mass concentration detection disturbance   , 3. µg-C/L}
!> \describepar{deltaT       , \Delta T       , global temperature change    , 0. ^oC}
!> \describepar{deltaCop     , \Delta_{cop}     , correlation copepod vs. temperature change    , 0. µg-C/L/^oC}
subroutine initialize(self, configunit)

class (type_hzg_jelly), intent(inout), target :: self
integer,                  intent(in)            :: configunit
!
! !LOCAL VARIABLES:
integer    :: namlst=19
!!------- Initial values of model jelly ------- 
!> \describepar{B_Pp_initial , B_\mathrm{Pp} , P.Pileus biomass, 3E-2 µg-C/L}
!> \describepar{l_Pp_initial , \ell_\mathrm{Pp} , P.Pileus mean log size, 1.4 log(ESD/mm)}
!> \describepar{B_Be_initial , B_\mathrm{Be} , Beroe biomass, 0E-4 µg-C/L}
!> \describepar{l_Be_initial , \ell_\mathrm{Be} , Beroe mean log size, 1.25 log(ESD/mm)}
!> \describepar{B_Det_initial , \ell_\mathrm{Det} , detritus, 180. µg-C/L}
!> \describepar{ParasPp_initial , \B_\mathrm{Pars,Pp} , parasite of P.Pileus, 1. µg-C/L}
!> \describepar{ParasBe_initial , \B_\mathrm{Pars,Be} , parasite of Beroe, 1. µg-C/L}
!> \describepar{BenTime_initial , t , time , 0. d}
real(rk)  :: B_Pp_initial ! P.Pileus biomass
real(rk)  :: l_Pp_initial ! P.Pileus mean log size
real(rk)  :: B_Be_initial ! Beroe biomass
real(rk)  :: l_Be_initial ! Beroe mean log size
real(rk)  :: B_Det_initial ! detritus
real(rk)  :: ParasPp_initial ! parasite of P.Pileus
real(rk)  :: ParasBe_initial ! parasite of Beroe
real(rk)  :: BenTime_initial ! time 
!> describepar{lA           , \ell_A           , adult ctenophore size        , 2.0 log(ESD/mm)}
!> describepar{l0           , \ell_0           , offspring size, -1.2 log(ESD/mm)}
!> describepar{lstarv       , \ell_S       , minimum starvation size, 2. log(ESD/mm)}
!> describepar{sigma        , \sigma'        , log-size specific std deviation , 1. log(ESD/mm)^2}
!> describepar{Imax_pot     , I_\mathrm{max}^*     , maximum ingestion rate for ideal consumer, prey, T, and food , 173. 1/d}
!> describepar{yield        , y_0        , assimilation efficiency, 0.4 }
!> describepar{mR           , m_R^0           , temperature dependent, natural mortality rate , 0.02 1/d}
!> describepar{mS           , m_S^0           , physiological mortality under senescence , 3.E-2 1/d}
!> describepar{mP           , m_P^0           , density dependent mortality rate (parasites), 1.6E-5 1/d.µg-C/L}
!> describepar{mT           , m_{T}^0           , mortality due to physical damage (turbulence) 0.028, 0. 1/d}
!> describepar{Q10          , Q_{10}          , rate increase at 10C temperature rise, 2. }
!> describepar{Tc           , ^o$C] $T_c           , critical threshold temperature, 4.5 $^o$C}
!> describepar{Bcrit        , B^*        , minimal prey biomass (Holling-III) , 25. µg-C/L}
!> describepar{relCVDens    , R_\rho    , C-biovolume density ratio non-gelatinous/gelatinous plankton, 120.0 µg-C/L}
!> describepar{m_predBe     , m_\mathrm{top}     , loss rate of Beroe due to top-predator , 0. 1/d}
!> describepar{loptA_Pp     , \lcsize_\mathrm{opt,Pp}^A     , optimal prey size adult P.pileus , -0.6 }
!> describepar{loptA_Be     , \lcsize_\mathrm{opt,Be}^A     , optimal prey size adult Beroe , 2. }
!> describepar{immigr       , \epsilon_\mathrm{in}       , migration mass inflow rate , 5e-06 µg-C/L.d}
!> describepar{rDet         , r_\mathrm{Det}         , detritus turnover rate , 0.05 1/d}
!> describepar{rParasite    , r_\mathrm{Pars}    , turnover parasite dynamics, 1. }
!> describepar{fTDmort      , f_0      , warm temperature detritus ''feed-back''   , 0.5 }
!> describepar{m_pcap       ,        , dependency of parasite dynamics on host/detritus biomass, 25. }
!> describepar{mDisturb     , B_\mathrm{cd}     , critical mass concentration detection disturbance   , 3. µg-C/L}
!> describepar{deltaT       , \Delta T       , global temperature change    , 0. ^oC}
!> describepar{deltaCop     , \Delta_{cop}     , correlation copepod vs. temperature change    , 0. µg-C/L/^oC}
!!------- Parameters from nml-list jelly_pars ------- 
real(rk)  :: lA           ! adult ctenophore size        
real(rk)  :: l0           ! offspring size
real(rk)  :: lstarv       ! minimum starvation size
real(rk)  :: sigma        ! log-size specific std deviation 
real(rk)  :: Imax_pot     ! maximum ingestion rate for ideal consumer, prey, T, and food 
real(rk)  :: yield        ! assimilation efficiency
real(rk)  :: mR           ! temperature dependent, natural mortality rate 
real(rk)  :: mS           ! physiological mortality under senescence 
real(rk)  :: mP           ! density dependent mortality rate (parasites)
real(rk)  :: mT           ! mortality due to physical damage (turbulence) 0.028
real(rk)  :: Q10          ! rate increase at 10C temperature rise
real(rk)  :: Tc           ! critical threshold temperature
real(rk)  :: Bcrit        ! minimal prey biomass (Holling-III) 
real(rk)  :: relCVDens    ! C-biovolume density ratio non-gelatinous/gelatinous plankton
real(rk)  :: m_predBe     ! loss rate of Beroe due to top-predator 
real(rk)  :: loptA_Pp     ! optimal prey size adult P.pileus 
real(rk)  :: loptA_Be     ! optimal prey size adult Beroe 
real(rk)  :: immigr       ! migration mass inflow rate 
real(rk)  :: rDet         ! detritus turnover rate 
real(rk)  :: rParasite    ! turnover parasite dynamics
real(rk)  :: fTDmort      ! warm temperature detritus ''feed-back''   
real(rk)  :: m_pcap       ! dependency of parasite dynamics on host/detritus biomass
real(rk)  :: mDisturb     ! critical mass concentration detection disturbance   
real(rk)  :: deltaT       ! global temperature change    
real(rk)  :: deltaCop     ! correlation copepod vs. temperature change    
!!------- Switches for configuring model structure -------
logical   :: TransectOn   ! mixing between coastal transect boxes
logical   :: SizeDynOn    ! life stage cycling enabled
logical   :: LowPassOn    ! filter high frequency in forcing
logical   :: OptionOn     ! generic
logical   :: TEcophysOn   ! size dependency in mortality

namelist /jelly_init/ &
  B_Pp_initial, l_Pp_initial, B_Be_initial, l_Be_initial, B_Det_initial, &
  ParasPp_initial, ParasBe_initial, BenTime_initial

namelist /jelly_pars/ &
  lA, l0, lstarv, sigma, Imax_pot, yield, mR, mS, mP, mT, Q10, Tc, Bcrit, relCVDens, m_predBe, &
  loptA_Pp, loptA_Be, immigr, rDet, rParasite, fTDmort, m_pcap, mDisturb, deltaT, &
  deltaCop

namelist /jelly_switch/ &
  TransectOn, SizeDynOn, LowPassOn, OptionOn, TEcophysOn

B_Pp_initial = 3E-2_rk            ! µg-C/L
l_Pp_initial = 1.4_rk             ! log(ESD/mm)
B_Be_initial = 0E-4_rk            ! µg-C/L
l_Be_initial = 1.25_rk            ! log(ESD/mm)
B_Det_initial = 180._rk            ! µg-C/L
ParasPp_initial = 1._rk              ! µg-C/L
ParasBe_initial = 1._rk              ! µg-C/L
BenTime_initial = 0._rk              ! d
lA           = 2.0_rk             ! log(ESD/mm)
l0           = -1.2_rk            ! log(ESD/mm)
lstarv       = 2._rk              ! log(ESD/mm)
sigma        = 1._rk              ! log(ESD/mm)^2
Imax_pot     = 173._rk            ! 1/d
yield        = 0.4_rk             ! 
mR           = 0.02_rk            ! 1/d
mS           = 3.E-2_rk           ! 1/d
mP           = 1.6E-5_rk          ! 1/d.µg-C/L
mT           = 0._rk              ! 1/d
Q10          = 2._rk              ! 
Tc           = 4.5_rk             ! $^o$C
Bcrit        = 25._rk             ! µg-C/L
relCVDens    = 120.0_rk           ! µg-C/L
m_predBe     = 0._rk              ! 1/d
loptA_Pp     = -0.6_rk            ! 
loptA_Be     = 2._rk              ! 
immigr       = 5e-06_rk           ! µg-C/L.d
rDet         = 0.05_rk            ! 1/d
rParasite    = 1._rk              ! 
fTDmort      = 0.5_rk             ! 
m_pcap       = 25._rk             ! 
mDisturb     = 3._rk              ! µg-C/L
deltaT       = 0._rk              ! ^oC
deltaCop     = 0._rk              ! µg-C/L/^oC


!--------- read namelists --------- 
write(0,*) ' read namelists ....'
open(namlst,file='jelly_init.nml',status='old')
read(namlst,nml=jelly_init,err=90,end=99)
open(namlst,file='jelly_pars.nml',status='old')
read(namlst,nml=jelly_pars,err=91,end=100)
open(namlst,file='jelly_switch.nml',status='old')
read(namlst,nml=jelly_switch,err=92,end=101)
! Store parameter values in our own derived type
! NB: all rates must be provided in values per day,
! and are converted here to values per second.

!!------- logical parameters: switches  -------
call self%get_parameter(self%TransectOn,    'TransectOn',    default=TransectOn)
call self%get_parameter(self%SizeDynOn,     'SizeDynOn',     default=SizeDynOn)
call self%get_parameter(self%LowPassOn,     'LowPassOn',     default=LowPassOn)
call self%get_parameter(self%OptionOn,      'OptionOn',      default=OptionOn)
call self%get_parameter(self%TEcophysOn,    'TEcophysOn',    default=TEcophysOn)

!!------- model parameters from nml-list jelly_init ------- 
call self%get_parameter(self%B_Pp_initial ,'B_Pp_initial',  default=B_Pp_initial)
call self%get_parameter(self%l_Pp_initial ,'l_Pp_initial',  default=l_Pp_initial)
call self%get_parameter(self%B_Be_initial ,'B_Be_initial',  default=B_Be_initial)
call self%get_parameter(self%l_Be_initial ,'l_Be_initial',  default=l_Be_initial)
call self%get_parameter(self%B_Det_initial ,'B_Det_initial',  default=B_Det_initial)
call self%get_parameter(self%ParasPp_initial ,'ParasPp_initial',  default=ParasPp_initial)
call self%get_parameter(self%ParasBe_initial ,'ParasBe_initial',  default=ParasBe_initial)
call self%get_parameter(self%BenTime_initial ,'BenTime_initial',  default=BenTime_initial)

!!------- model parameters from nml-list jelly_pars ------- 
call self%get_parameter(self%lA           ,'lA',            default=lA)
call self%get_parameter(self%l0           ,'l0',            default=l0)
call self%get_parameter(self%lstarv       ,'lstarv',        default=lstarv)
call self%get_parameter(self%sigma        ,'sigma',         default=sigma)
call self%get_parameter(self%Imax_pot     ,'Imax_pot',      default=Imax_pot)
call self%get_parameter(self%yield        ,'yield',         default=yield)
call self%get_parameter(self%mR           ,'mR',            default=mR)
call self%get_parameter(self%mS           ,'mS',            default=mS)
call self%get_parameter(self%mP           ,'mP',            default=mP)
call self%get_parameter(self%mT           ,'mT',            default=mT)
call self%get_parameter(self%Q10          ,'Q10',           default=Q10)
call self%get_parameter(self%Tc           ,'Tc',            default=Tc)
call self%get_parameter(self%Bcrit        ,'Bcrit',         default=Bcrit)
call self%get_parameter(self%relCVDens    ,'relCVDens',     default=relCVDens)
call self%get_parameter(self%m_predBe     ,'m_predBe',      default=m_predBe)
call self%get_parameter(self%loptA_Pp     ,'loptA_Pp',      default=loptA_Pp)
call self%get_parameter(self%loptA_Be     ,'loptA_Be',      default=loptA_Be)
call self%get_parameter(self%immigr       ,'immigr',        default=immigr)
call self%get_parameter(self%rDet         ,'rDet',          default=rDet)
call self%get_parameter(self%rParasite    ,'rParasite',     default=rParasite)
call self%get_parameter(self%fTDmort      ,'fTDmort',       default=fTDmort)
call self%get_parameter(self%m_pcap       ,'m_pcap',        default=m_pcap)
call self%get_parameter(self%mDisturb     ,'mDisturb',      default=mDisturb)
call self%get_parameter(self%deltaT       ,'deltaT',        default=deltaT)
call self%get_parameter(self%deltaCop     ,'deltaCop',      default=deltaCop)

!!------- Register state variables  ------- 
call self%register_state_variable(self%id_B_Pp,  'B_Pp','µg-C/L','P.Pileus biomass B_Pp', &
   B_Pp_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_l_Pp,  'l_Pp','log(ESD/mm)','P.Pileus mean log size l_Pp', &
   l_Pp_initial, minimum=-3.0d0, no_river_dilution=.true. )
call self%register_state_variable(self%id_B_Be,  'B_Be','µg-C/L','Beroe biomass B_Be', &
   B_Be_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_l_Be,  'l_Be','log(ESD/mm)','Beroe mean log size l_Be', &
   l_Be_initial, minimum=-3.0d0, no_river_dilution=.true. )
call self%register_state_variable(self%id_B_Det, 'B_Det','µg-C/L','detritus B_Det', &
   B_Det_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_ParasPp, 'ParasPp','µg-C/L','parasite of P.Pileus ParasPp', &
   ParasPp_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_ParasBe, 'ParasBe','µg-C/L','parasite of Beroe ParasBe', &
   ParasBe_initial, minimum=_ZERO_, no_river_dilution=.true. )
call self%register_state_variable(self%id_BenTime, 'BenTime','d','time  BenTime', &
   BenTime_initial, minimum=_ZERO_, no_river_dilution=.true. )

!!------- Register diagnostic variables  ------- 
call self%register_diagnostic_variable(self%id_prod_Be, 'prod_Be','1/d', 'secondary production rate Beroe prod_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Be, 'Mort_Be','1/d', 'mortality rate of Beroe Mort_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Be,   'fA_Be','1/d', 'relative propotion adults Beroe fA_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Be, 'Imax_Be','1/d', 'maximum ingestion rate adult Beroe Imax_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_lopt_Be, 'lopt_Be','1/d', 'optimum prey size Beroe lopt_Be', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_Pp, 'prod_Pp','1/d', 'secondary production rate P pileus prod_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Mort_Pp, 'Mort_Pp','1/d', 'mortality rate of P pileus Mort_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_fA_Pp,   'fA_Pp','1/d', 'relative proportion adults P pileus fA_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Imax_Pp, 'Imax_Pp','1/d', 'maximum ingestion rate adult Beroe Imax_Pp', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_P,  'mort_P','1/d', 'density dependent mortality - parasites mort_P', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_S,  'mort_S','1/d', 'physiological adult mortality rate mort_S', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_R,  'mort_R','1/d', 'temperature dependent mortality mort_R', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_G,  'mort_G','1/d', 'top-predation mort_G', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_J,  'mort_J','1/d', 'juvenile mortality mort_J', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mort_T,  'mort_T','1/d', 'damaging effect of turbulence mort_T', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_somgrowth, 'somgrowth','1/d', 'somatic growth rate  somgrowth', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_recruit, 'recruit','1/d', 'egg production rate  recruit', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_paras_dl, 'paras_dl','1/d', 'marginal size shift parasites paras_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_som_dl,  'som_dl','1/d', 'marginal size shift due to promotion som_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_turb_dl, 'turb_dl','1/d', 'marginal size shift due to physical damage turb_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_init_dl, 'init_dl','1/d', 'marginal size shift due to egg production init_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_graz_dl, 'graz_dl','1/d', 'marginal size shift due to selective grazing graz_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_sen_dl,  'sen_dl','1/d', 'marginal size shift due to starvation  sen_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_prod_dl, 'prod_dl','1/d', 'marginal size shift due to production  prod_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_resp_dl, 'resp_dl','1/d', 'marginal size shift due to respiration  resp_dl', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_prey, 'dl_prey','1/d', 'size difference to prey  dl_prey', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_dl_pred, 'dl_pred','1/d', 'size difference to pred  dl_pred', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_al_Im,   'al_Im','1/d', 'size scaling exponent Imax  al_Im', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixBmass, 'mixBmass','1/d', 'mass exchange rate Coast-HR-Offshore mixBmass', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_mixlsize, 'mixlsize','1/d', 'trait exchange rate Coast-HR-Offshore mixlsize', &
  output=output_instantaneous)
call self%register_diagnostic_variable(self%id_Tdep,    'Tdep','1/d', 'Temperature dependency Tdep', &
  output=output_instantaneous)

!!------- Register environmental dependencies  ------- 
call self%register_dependency(self%id_Cop,standard_variables%downwelling_photosynthetic_radiative_flux)
call self%register_dependency(self%id_Temp,standard_variables%temperature)
call self%register_dependency(self%id_Phy,standard_variables%practical_salinity)

! extra line included from parser var init_incl 
#define UNIT *1.1574074074E-5_rk

relC    = self%deltaT * self%deltaCop / 29.d0
fC      = (1.0d0+relC)/(1.d0 + relC * (1.d0 - 0.5*exp(0.5+3*relC*relC*relC)));


return

!!-------  if files are not found ...  
90 call self%fatal_error('jelly_init','Error reading namelist jelly_init.')
91 call self%fatal_error('jelly_init','Error reading namelist jelly_pars.')
92 call self%fatal_error('jelly_init','Error reading namelist jelly_switch.')
99 call self%fatal_error('jelly_init','Namelist jelly_init was not found in file.')
100 call self%fatal_error('jelly_init','Namelist jelly_pars was not found in file.')
101 call self%fatal_error('jelly_init','Namelist jelly_switch was not found in file.')

end subroutine initialize

!!----------------------------------------------------------------------
!!   end of section generated by parser 
!!----------------------------------------------------------------------
! #SP#"
!
!INTERFACE:
  subroutine do(self,_ARGUMENTS_DO_)
!
! !INPUT PARAMETERS:
  class (type_hzg_jelly),intent(in) :: self
  _DECLARE_ARGUMENTS_DO_
!
!LOCAL VARIABLES:

  type (type_jelly_var), dimension(3)       :: var
  type (type_jelly_rhs)       :: rhsv
  !type (type_diff)      :: diff,diff2
  !real(rk)              :: d2mudl2_d, dmu2=0.0_rk, mfac
!  type (type_environment),   intent(inout)  :: environment 
  real(rk) :: mort_S, mort_S0,mort_SJ, mort_T0, mort_G, mort_top
  real(rk) :: mort_J, mort_AJ, mort_T, mort_sum, mass_sum, doy, arg2
  real(rk) :: errf, eargA, argA, aa, eS, eS0, al0,alr, yfac, affin
  real(rk) :: Imaxr, lesdr, efn, efp, dll,loptm, sBDet, detect, sr, ft
  real(rk) :: somgrwth, recruit,lco, mGBe, f_tc, starv, dal_dl, min_dl, bound_dl
  real(rk) :: prod_dl, sum_dl, resp_dl,paras_dl, turb_dl,tempp, mass3
  real(rk) :: graz_dl, som_dl, init_dl, sen_dl,ft2,meanT,mben
  real(rk), dimension(2,numb) :: dConc,dTrait
  real(rk), dimension(3) :: Imax, Imact, di_dl, di0_dl, dg_dly, dprod_dl
  real(rk), dimension(3) :: dlopt,lopt, graz,Temp_dep,sig13, sig23, ksat
  real(rk), dimension(3) :: mGrz, sig, sigma2, lmsize, mass, relDens
  real(rk), dimension(3) :: mort_R, mort_R0, mort_P
  real(rk), dimension(3) :: loptA, preyc, paras, fLc, m_host,rpara, pS
  real(rk), dimension(3,3):: grss
  real(rk), dimension(51):: mAurelia60, mCyanea60
  real(rk) :: dl0, dl, dl2, bcrit, prey, preyE, preyT, preyTa, mGP
  real(rk) :: fR, fA, dfA_dl, lm_adult, al, lprey, lavg, aff, activ, eps
  real(rk) :: gross, prod, dg_dB, dp_dB, dp_dl, mS0, mT0, ratf, no_age, cnid, reltim
  integer  :: ib, ic, i, j, maxpred, yi
  logical  :: IsExp, IsOut, IsMaxIng 
!					Be     Pp     Cop
  integer  :: webtopo(3,3) = reshape((/0,1,0, 1,1,1, 0,0,0/), (/3,3/))
!  fortran organizes arrays as column major
!  real(rk) :: inflow=2E-1, Adorm=2E-3

! !REVISION HISTORY:
!  Original author(s): Kai Wirtz

! !DESCRIPTION:
! Stage-based Pleurobrachia & Beroe   Model
!
!EOP
!-----------------------------------------------------------------------
!BOC
eps      =  1E-5    ! small number that avoids division by zero
IsExp    =  .false. ! scenario flag, may be changed due to forcing signal
!***!
IsMaxIng =  .false. ! correction of Imax-scaling at small size
meanT    =  10.2d0  ! mean HR water temperature (only used for scenario runs)
no_age   =  0.5d0   ! relative importance of stage independent sensitivity
!write (*,'(A,4(I3))') 'w=',webtopo(3,1),webtopo(2,2),webtopo(1,3),webtopo(3,3)
if(webtopo(1,3)+webtopo(2,3)+webtopo(3,3) .gt. 0) then
  maxpred = 3
else
  maxpred = 2
endif

! annual TS abundance data for scyphomedusae from VanWalraven et al 2014 
mAurelia60 =(/ 2.133,0.213,0.000,7.253,0.000,0.213,0.213,0.427,0.000,0.000,0.000,0.000,0.000,0.000,0.000,0.640,0.000,0.000,72.960,0.427,30.080,47.787,10.667,0.853,20.053,77.013,9.387,24.960,6.400,10.667,9.387,31.147,26.667,16.427,4.267,29.227,4.693,7.253,2.133,0.640,0.427,4.053,7.893,12.587,0.213,0.000,0.000,27.733,3.840,0.213,22.613 /)
mCyanea60  =(/ 0.033,0.000,0.000,0.780,0.423,0.195,0.033,0.553,0.033,0.000,0.000,0.748,1.301,0.065,2.211,0.325,0.585,0.228,0.033,0.033,0.325,5.236,0.358,0.423,0.520,9.138,2.699,0.585,1.528,1.691,5.463,2.472,0.065,3.089,1.203,0.195,10.862,0.748,0.358,0.423,0.260,0.455,1.789,6.667,1.203,0.390,2.146,11.740,1.171,0.098,0.618 /)

! Enter spatial loops (if any)
_FABM_LOOP_BEGIN_

! here box set-up within fabm-0D driver
! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb

!#S_GET
!---------- GET for each state variable ----------
  _GET_(self%id_B_Pp, var(ib)%B_Pp)  ! P.Pileus biomass in µg-C/L
  _GET_(self%id_l_Pp, var(ib)%l_Pp)  ! P.Pileus mean log size in log(ESD/mm)
  _GET_(self%id_B_Be, var(ib)%B_Be)  ! Beroe biomass in µg-C/L
  _GET_(self%id_l_Be, var(ib)%l_Be)  ! Beroe mean log size in log(ESD/mm)
  _GET_(self%id_B_Det, var(ib)%B_Det)  ! detritus in µg-C/L
  _GET_(self%id_ParasPp, var(ib)%ParasPp)  ! parasite of P.Pileus in µg-C/L
  _GET_(self%id_ParasBe, var(ib)%ParasBe)  ! parasite of Beroe in µg-C/L
  _GET_(self%id_BenTime, var(ib)%BenTime)  ! time  in d
!#E_GET
   ! Retrieve current environmental conditions.
!#S_GED
  _GET_(self%id_Cop, var(ib)%Cop)  ! biomass from Greve data-set
  _GET_(self%id_Temp, var(ib)%Temp)  ! temperature HR
  _GET_(self%id_Phy, var(ib)%Phy)  ! phytoplankton biomass HR
!#E_GED

 end do
!
! ---------- set environmental conditions for each box  -------------------
!
! ib=1 HR   2: Coast  3:Offshore
! open water: less copepods, and reduced temperature fluctuation
!  var(2)%Cop  = 1.5 * var(2)%Cop!  var(2)%Temp = -0.5 + 1.15*var(2)%Temp
   mben = 850.0d0

if (var(1)%BenTime .lt. 6.0d0) then
  mben = 700.0d0
else
 if (var(1)%BenTime .lt. 17.0d0) then
   mben = 950.0d0
 else
   mben = 950.0d0+(var(1)%BenTime-17.0d0) * 50.0d0
 endif
endif
!if (var(1)%BenTime .lt. 7.4d0) then   cnid = 1.0d0
!else   cnid = 5.0d0 endif

yi = FLOOR(var(1)%BenTime)  ! year index relative to 1960
reltim      = var(1)%BenTime - yi - 0.56 ! peak abundance around day 200
reltim      = reltim / 0.22  
if (yi+14 .lt. 51) then
 cnid = (mAurelia60(yi+14)+mCyanea60(yi+14))* exp(-reltim**2)
else
 cnid = 0.0d0
endif

! loop over boxes   1: HR  2: Offshore
 do ib = 1, numb
!
! ---------- set specific variables for each population  -------------------
!
! set coefficient vectors over prey populations:  1: Beroe 2: Ppileus  3: Cops
  lmsize(1) = var(ib)%l_Be  ! mean body size of population
  lmsize(2) = var(ib)%l_Pp  ! 
  lmsize(3) = -0.6d0        ! small copepods dominate. ! TODO: include as forcing 
  sigma2(3) = 0.8d0         ! log-size variance of mesozooplakton
  mass(1)   = var(ib)%B_Be  ! biomass concentration
  mass(2)   = var(ib)%B_Pp
  mass(3)   = var(ib)%Cop  ! global correction for too low prey/cop biomass
 ! pass binary info through sign of copepod input 
  if ( mass(3) .lt. 0.0d0) then
    mass(3)= -mass(3)
    IsExp  = .true.
  else
    IsExp  = .false.
  endif
  if ( abs(mass(3)-50.) .lt. -0.0001d0 .or. abs(mass(3)-5.) .lt. -0.0001d0) then
      IsOut= .true.
  write (*,'(A,3(F12.4))') 'm=',mass(1)*1E3,mass(2)*1E3,mass(3)
  write (*,'(A,3(F12.4))') 'l=',lmsize(1),lmsize(2),lmsize(3)

  else
     IsOut = .false.
  endif

! scenario: temp change correlates with cop change
  if( abs(self%deltaCop) .gt. 1E-3 .and. abs(self%deltaT) .gt. 1E-3) then 
     mass(3) = mass(3) * fC * (1.0d0+relC*(1.d0-exp(1.d0-mass(3)/29.d0)))
  endif

! scenario: temp change 
  if(self%TEcophysOn  .and. (IsExp .or. self%deltaT .gt. 0.0d0)) then 
      tempp     = var(ib)%Temp+self%deltaT*exp((meanT-var(ib)%Temp)/(2*meanT))
  else
      tempp     = var(ib)%Temp
  endif

! parasite states into vector
  paras(1)  = var(ib)%ParasBe
  paras(2)  = var(ib)%ParasPp

! assignment of group specific parameters 
! rel. C-biovolume density ratio of non-gelatinous plankton
  relDens(1)= self%relCVDens ! Be:   jelly
  relDens(2)= self%relCVDens ! Pp:   jelly
  relDens(3)= 1.0d0          ! Cops: non-jelly
! opt-prey-size change during ontogeny
  dlopt(1)  = (self%loptA_Be-self%l0)/(self%lA-self%l0) ! increase in l_opt; feeding mode development
  dlopt(2)  = (self%loptA_Pp-self%l0)/(self%lA-self%l0)
  dlopt(3)  = (-3.5d0-self%l0)/(lmsize(3)-self%l0)
!  lopt(3)  = (-2.0-self%l0)/(self%lA-self%l0)
!  loptm(3)  = lopt(3)
!  Imax(3)   = 1.0d0
  Temp_dep(3) = f_temp(self%Q10+1.0d0, tempp, 0.0d0)

! re-gauge coefficient to apply  Imax-scaling of Wirtz JPR,2012 
!    log(1E3/80) converts from log(micro-m) to log(mm) but accounts for much lower C-density
! optimum size/stage with minimal life-stage dependent mortality 
  lavg    = 0.5d0*(self%lA + self%l0) ! 0.4
!  loop over ctenophore populations:  1: Beroe 2: Ppileus 
! effect of reduces prey detectability at high consumer density

  mass3   = abs(var(ib)%Cop)
! temperature experiment; separate effect on parasite dynamics through altered copepod/detrital mass
  if(self%OptionOn .and. abs(self%deltaCop) .gt. 1E-3 .and. abs(self%deltaT) .gt. 1E-3) then 
     mass3   =  mass3* fC * (1.0d0+relC*(1.d0-exp(1.d0-mass3/29.d0)))
  endif
!  if(mass3 .gt. 175.) mass3 = 175.0d0

!***!
!  sr      = 0.*exp(-(lmsize(1)-lmsize(3))**2/(2*sigma2(3))) * mass3
  sr      = 1.*exp(-(self%lA-lmsize(3))**2/(2*sigma2(3))) * mass3
!  sr      = sr + 2.*exp(-(self%lA-lmsize(3)*2)**2/(2*sigma2(3))) * var(ib)%B_Det
  detect  = (mass(1)+mass(2)+sr)/self%mDisturb !*exp(lmsize(i)-lopt(i))
!  detect  = (mass(1)+mass(2)+exp(-1.5d0*(self%lA-0.)**2)*var(ib)%B_Det)/self%mDisturb !*exp(lmsize(i)-lopt(i))
!   detect  = 2.0d0/(1.0d0+exp(detect))


  do i = 1, maxpred
    lco       = log(1E3/relDens(i))
    lopt(i)   = self%l0 + (lmsize(i)-self%l0)*dlopt(i) ! optimal prey size
    loptA(i)  = self%l0 + (self%lA-self%l0)*dlopt(i) ! optimal prey size
 !Temp_dep(3)fLc* * *exp(0.5*(lmsize(i)-lavg-lopt(i)))
! potential maximum ingestion rate depending on size, T, and feeding mode
   ! re-gauge log size to µm-scale used in Wirtz JPR,2012     log(1E3/80)=2.5
   !    converts from log(µm) to log(mm) but accounts for much lower C-density  
!    lesdr     = 0.0d0
    if (IsMaxIng) then
! correction to prevent unrealistic Imax-size dependency for juveniles (see Fig.4 Wirtz JPR 2013)
!***!
!      argA      = lmsize(i)/lavg
      argA      = lmsize(i)
      efp       = exp(argA)
      efn       = exp(-argA)
      lesdr   = (lmsize(i)*efp + 1.0)/(efp+efn)
!      lesdr   = (lmsize(i)*efp + lavg)/(efp+efn)
      loptm   = self%l0 + (lesdr-self%l0)*dlopt(i) ! optimal prey size
    else
      lesdr   = lmsize(i)
      loptm   = lopt(i) ! optimal prey size
    endif
! temperature dependency for egg spawning, somatic growth and mortalities 
    if (i .lt. 3) then
  !! TODO: refine empirical relationship using Falkenhaug1996 or Finenko2003 data 
!***!
      sigma2(i) = self%sigma * exp(-0.5*(lavg-lmsize(i))**2) *(1.0d0-(i-1)*0.2)
      sig(i)    = sqrt(sigma2(i))  
      Temp_dep(i) = f_temp(self%Q10+0.*lopt(i), tempp, self%Tc)
      al      = -0.41d0 * (loptm-lesdr)
      Imax(i) = self%Imax_pot *Temp_dep(i) *  exp( al + (2-al)*(loptm+lco) +(al-3)*(lesdr+lco) )
    else
      Imax(i) = Temp_dep(3)
    endif 

! size derivative of Imax-scaling
    dal_dl     = 0.41d0 * (1.0 - dlopt(i))
    di0_dl(i)  = (al-3) + dlopt(i)*(2-al) + dal_dl*(1.0d0 - loptm + lesdr)

    if (IsMaxIng) then
!    if (.true.) then
      dll       = ( (1.0d0+argA)*(efp*efp+1.0d0) - (efp+efn)*(argA*efp+1.0d0))/(efp+efn)**2
      di0_dl(i) = di0_dl(i)* dll
    endif

! set accumulating stores to zero
!    graz(i)   = 0.0d0
  end do

! temperature experiment; separate effect on parasite dynamics
  if( self%OptionOn .and. (IsExp .or. self%deltaT .gt. 0.0d0)) then 
     tempp  = var(ib)%Temp + self%deltaT*exp((meanT-var(ib)%Temp)/(2*meanT))
  else
     tempp  = var(ib)%Temp
  endif


!  ft        = exp(-Temp_dep(2)/self%fTDmort);
  ft2     = f_temp(self%Q10,tempp , self%Tc)
  ft      = self%fTDmort/(self%fTDmort+ft2)
 ! ft      = exp(-ft2/self%fTDmort)
!***!

! Dekinga2007/Kraan2008: 16 (1970) - 56 (2005) gAFDW/m2 Wadden Sea
! representtive for entire SNS :Heip1992  /16m *0.5 -> 1000 mgC/m3 
  mass_sum= (1*mben + 000.0 + 1*var(ib)%B_Det) 
  mass_sum= (mass_sum+ mass(1)+ mass(2)+ mass3 + var(ib)%Phy )*exp(-ft2)!*exp(ft-1)
!  mass_sum= mass_sum  + 1*var(ib)%Phy !5*self%fTDmort*
!   starv    = exp(ft-argA)!self%yield *

  do j = 1, 3
    dg_dly(j) = 0.0d0
    mGrz(j)   = 0.0d0
! integration result with Gaussian size distribution (cf. effective prey biomass)
    sig23(j)   = 1.5d0/(1.0d0 + 3*sigma2(j))  ! "life-span"=1 : width of life-stage dependent mortality
    sig13(j)   = 1.0d0/sqrt(1.0d0 + 3*sigma2(j))
  end do

! common variable: most simple detritus pool turnover dynamics 
! first the detritus change, as detrivory influences parasites
! ---------- calculate RHS  -------------------
  rhsv%B_Det   = self%rDet * (mass_sum - var(ib)%B_Det)  ! 
!  ft2        = f_temp(self%Q10,tempp, 0.0d0)  ! temperature dep of quadratic parasite mortality 

! Parasite dynamics for each population
  do i = 1, 2 ! loop over parasites
!    fLc(j)    = sig13(i) *exp(-(lopt(j)-lmsize(3))**2)
!    fLc(i)    = exp(-sig23(i) * (loptA(i)-lmsize(3))**2)
    fLc(i)    = exp(-1.5d0*(loptA(i)-lmsize(3))**2)
!    m_host(i) = mass(i)+self%fTDmort*var(ib)%B_Det+fLc(i)*mass(3)sig23(i) *
! abundance of parasite hosts 
!    m_host(i) = mass(i) + fLc(i) * (mass3 + self%fTDmort*var(ib)%B_Det + mass3* self%fTDmort*var(ib)%B_Det/self%m_pcap)
    m_host(i) = mass(i) + fLc(i)*mass3
!    m_host(i) = mass(1) +mass(2) + fLc(i)*mass3

    sr        = self%rParasite * paras(i)
! quadratic parasite mortality 
    ft2       = var(ib)%B_Det/self%m_pcap
    bcrit     = Temp_dep(3) *m_host(i)/self%m_pcap * ft2
!***!
    rpara(i)  = sr * (bcrit - paras(i)/(ft2 * Temp_dep(3) + eps))
  end do

  rhsv%ParasBe = rpara(1)
  rhsv%ParasPp = rpara(2)
  rhsv%BenTime = 1.0d0/365

! ----------  loop over all trophic interactions  -------------------
!
!  loop over (ctenophore) predators
  do i = 1, maxpred
   dp_dl   = 0.0d0
   preyTa  = 0.0d0
   preyT   = 0.0d0
   gross   = 0.0d0
   do j = 1, 3  ! calc total available prey biomass first
     if (webtopo(j,i) .gt. 0) then
       dl      = lmsize(j) - lopt(i)     ! size match to prey
       if(i .eq. 3 .and. dl .gt. 1.5 ) dl = lmsize(j) + 2*loptA(j) - lopt(i)
! ingestion kernel
       Imact(j)= Imax(i) * exp(-1.5d0 * dl**2)
! effective prey mass after integration over selection kernel, with "neutral" selectivity s=3/2
       preyc(j)= sig13(j) * exp(-sig23(j)*dl**2)  
!     if (i.eq.1 .and. j.eq.3 ) then preyc(j)= 0   Imact(j)= 0    endif
! reduce cannibalism in Beroe (Hosia2011)     
! contribution to consumer size scaling in Imax 
       di_dl(j)= di0_dl(i) + 3*dl*dlopt(i)
!     preyc(j)= prey_effc(dl2)  ! effective prey mass after integration over selection kernel
       preyT   = preyT + preyc(j) * mass(j)  ! effective  prey mass after integration over selection kernel
       preyTa   = preyTa + preyc(j) * (relDens(j)**0.667) * mass(j)  ! tranformation into -relative- biovolume
     endif
   end do

! mortality due to parasites maximal at newly hetched larvae (Hirota1974 ,Greve)
!   pS(i)      = 1.0d0/(1.0d0+exp((self%lA-lmsize(i))/lavg))
   pS(i)      = 1.0d0/(1.0d0+exp(2*(self%lA-lmsize(i))))
! life-stage dependent mortality due to parasites
! fraction of large "meso"zooplakton as suitable parasite host 
!   mort_P  = self%mP * Temp_dep(3)**2 *(1.0d0+pS) * (fLc(i)*var(ib)%B_Det*1E-3)**2 
!   bcrit   = paras(i)/(1.0d0+paras(i)/5E14)
   bcrit   = paras(i)
!   bcrit   = fLc(i)*var(ib)%B_Det
!   bcrit   = 0.55*(paras(i) + fLc(i)*paras(2))
!***!
   mort_P(i)  = self%mP * Temp_dep(3) *(no_age+pS(i)) *bcrit ! * 4.0d0/(4.0d0+self%mP * bcrit)
! if (mort_P(i) .gt. 3.0d0 ) write (*,'(A,1(I2),3(F14.3))') 'mp=',i,paras(i),m_host(i),mort_P(i)

! affinity contains depes on food type (gel), consumer density, Temp, size(swimming)
!  detect  = exp(-detect**2)
   affin     = 1.0d0/self%Bcrit *Temp_dep(i)* exp(0.5d0*lmsize(i))
!   sr      = 0.5*affin * preyTa / (self%mR*Temp_dep(i)*exp(-0.5*lmsize(i)))
! temperature dependent loss, with surface-to-volume scaling
!   mort_R  = self%mR * Temp_dep(i) * exp(-0.5*lmsize(i)+lavg-0*lopt(i))!)
   sr = f_temp(self%Q10+0.+ 0.*loptA(i), tempp, self%Tc)
!   mort_R0(i) = self%mR * Temp_dep(i) * exp(-0.5*lmsize(i)+0*loptA(i))!)
   mort_R0(i) = self%mR * sr * exp(-0.5*lmsize(i)-0.*loptA(i))!)

!***!
   sr        = affin * preyTa /(mort_R0(i)+eps)
!   sr      = 2*affin * preyTa /(self%mR+eps)
   activ     = 1.0d0 - exp(-sr)
   mort_R(i) = activ * mort_R0(i)
!   affin   = affin  * sr/(1.0d0 + sr)lmsize(i)
   affin     = affin  * activ * exp(-detect*detect) 
!  loop over prey populations:  1: Beroe 2: Ppileus 3: Cops
   do j = 1, 3 ! calc total available prey biomass first
     if (webtopo(j,i) .gt. 0) then

       ksat(j)    = Imact(j)/affin
       preyE      = preyc(j)* mass(j) ! effective prey mass after integration over selection kernel  
       eargA      = exp(-(affin*preyTa)/Imact(j))

! grazing rate (partial gross 2ndary production) of consumer i on prey j
       grss(i,j)  = Imact(j) * (1.0d0-eargA) * preyc(j)/(preyT+eps) ! * exp(-0*mort_P(i)/Imax(i))
       gross      = gross   + grss(i,j) * mass(j)
       mGrz(j)    = mGrz(j) + grss(i,j) * mass(i)

       if (IsOut) write (*,'(A,2(I2),1(F12.4))') 'gr=',i,j,grss(i,j)*1E3

! update size gradients in grazing rate
! size match to selective predation kernel 
! derivative of selection kernelexp(-1.5d0*(dl**2))*
       dg_dly(j)  = dg_dly(j) - (lmsize(j) - lopt(i))* grss(i,j)* mass(i) 
! affinity term; degree of food limitation (aff=0: g=Imax   aff=Imax: no food)
       aff        = affin*preyE* eargA  
! derivative with respect to prey mass
       dp_dB      = (grss(i,j)*(preyT-preyE)/(preyc(j)+eps)+(relDens(j)**0.667) *aff)/(preyT+eps)
! production derivative with respect to consumer size
!***!
       dp_dl      = dp_dl + dp_dB*2*sig23(j)*(lmsize(j)-lopt(i))* dlopt(i)
       dp_dl      = dp_dl + (grss(i,j)*mass(j)-aff)*di_dl(j) + 0.5*aff
!!! derivative with respect to consumer size (through optimal prey size dependency)     
     endif
   end do
! update all flux stores
!   graz(i) = graz(i) + gross
   graz(i)     = gross 
   dprod_dl(i) = dp_dl
  end do

!  loop over dynamic ctenophore populations 
  do i = 1, 2

! secondary production  
! physiological/starvation status affects yield (Reeve1989)
!   yfac    = 1.0d0/(1.0d0+mort_P(i)/(self%yield* graz(i)))
!   yfac    = exp(-mort_P(i)/(self%yield* graz(i))+eps)
   yfac     = exp(-2*mort_P(i)/(self%yield* graz(i))+eps)
!   yfac    = exp(-mort_P(i)/self%mR)
!   yfac    = 1.0d0
   prod     = self%yield * yfac * graz(i)
!
! ---------- energy losses & mortalities  -------------------
!

!       physiological/starvation mortality 
! life-stage dependent mortality 
   argA     = (prod-mort_R(i))/(0*mort_R0(i) + 1*self%mR)!self%mRmort_R* Temp_dep(i)
!   argA   = (prod+mort_R)/(exp(-1.0)*self%mR+eps) -2.0 -loptA(i)
!   argA   = (prod-exp(-1.0)*self%mR)/(mort_R(i)+exp(-1.0)*self%mR)
   ft       = self%fTDmort/(self%fTDmort+Temp_dep(i))
   arg2     = argA
!   starv    = exp(ft-argA)!self%yield *
   starv    = exp(-Temp_dep(i)-argA)!self%yield *

   mort_S0  = self%mS * starv !*exp(-lopt(i))
!   eS      = 0*sig13(i)* exp(-sig23(i)*(self%lA-lmsize(i))**2) 
   mort_S   = mort_S0  *(no_age+pS(i))!*(1.0d0-eS) 
!    if (abs(mort_S) .gt. 13.5) write (*,'(A,1(I2),4(F12.4))') 'mS=',i,mort_S,mort_S0,eS,starv
 


! physical damage (turbulence); can be avoided by active swimming
   mort_T0  = mT0 * starv 
   eS0      = sig13(i)* exp(-sig23(i)*(self%lA-lmsize(i))**2)
   mort_T   = mort_T0 * (1.0d0 - eS0) 

! --------  energy/carbon partitioning to egg production/somatic growth  ------------
!
!  how far way are juveniles from maturity ? 
   argA     = (self%lA-lmsize(i))/(sqrt(2.d0)*sig(i))

   errf     = (1-exp(-argA*2.45d0))/(1+exp(-argA*2.45d0))

!   call self%errfunc(argA, errf) ! TODO: replace by more accurate err-function
! relative fraction of adults 
   fA       = 0.5d0*(1.0d0 - errf) 
!   if (fa .lt. 0.0 .or. abs(fA) .gt. 1.) write (*,'(A,1(I2),5(F12.5))') 'fA=',i,lmsize(i),sig(i) ,argA,errf, fA 

! size derivative of adult fraction
!   dfA_dl= sqrt(2.d0*3.1415)/sig(i) * eargA
! mean adult size
   eargA    = exp(- argA*argA)
 !  if (eargA .gt. 1.2 .or. eargA .lt. 0.0001) write (*,'(A,1(I2),5(F12.5))') 'fA=',i,lmsize(i),sig(i) ,argA,eargA, fA 

   lm_adult = lmsize(i) + sig(i) / sqrt(2.d0*3.1415) * eargA / (abs(fA)+0.05d0)
!   lm_adult = lmsize(i) 

! fraction of adult secondary production allocated to recruitment
!***!
   fR       = 0.75d0*Temp_dep(i)
  
! rate at which adults spawn new eggs
   recruit  = fA * fR * prod

! somatic growth : TODO: temperature dependency
   somgrwth = prod - recruit - mort_R(i)  ! can become negative which is OK

! top-down pressure by larger jellies (cnidarians such as Aurelia Cyanea, or Chrysaora)
   mort_top = Temp_dep(3)*self%m_predBe  * cnid !* mass(i)

!  sum of all mortality rates
   mort_sum = mort_R(i) + mort_S  + mGrz(i)+ mort_P(i) + mort_top

!   if (abs(mort_sum) .gt. -0.5) write (*,'(A,1(I2),8(F12.5))') 'mort=',i, mort_sum ,lmsize(i),   fLc , Temp_dep(3), exp(-sig23(1)*(loptA(1)-lmsize(3))**2),mGrz(i),mort_P(i),sig23(1)
!
! ----------  stage and size dynamics  -------------------
!
   if (self%SizeDynOn) then
! egg production related part of size dynamics 
     init_dl  = (self%l0 - lm_adult) * recruit
 
! somatic growth related part of size dynamics 
     som_dl   = somgrwth/3

! marginal size shift due to selective grazing at neutral kernel width
!   shifts prey distribution away from l_opt_pred, thus to lower mortality
     graz_dl  = -sigma2(i) * dg_dly(i)

!  marginal size shift due to senescence
!     sen_dl  = 0.0d0
! size derivative 
     sr       = 2 * pS(i)**2 * exp(2*(self%lA-lmsize(i)))/(eps+no_age+pS(i))
     sen_dl   = -sigma2(i) *  mort_S0 * sr
!     sen_dl  = sigma2(i) * mort_S0 * eS * 2*sig23(i)* (self%lA-lmsize(i))

!  marginal size shift due to respiration and turbulence (same scaling exponent)
!    turb_dl  = sigma2(i) * mort_T0 * exp(-lmsize(i))
     turb_dl  = sigma2(i) * mort_T0 * eS0 *2*sig23(i)* (self%lA-lmsize(i))
!   mort_T  = mort_T0 * (exp((self%lA-lmsize(i))*0.5)+ exp(lmsize(i)*0.5))
     resp_dl  = sigma2(i) * mort_R(i) * 0.5*(1+0*dlopt(i))

!  marginal size shift due to density dependent mortality (parasites)
!     paras_dl = -sigma2(i) * mort_P(i) *2*sig23(i)* (self%lA-lmsize(i))!/(0*f_tc+pS+0*starv)*pS/(starv*0+1.+pS+1.0E-4)
     paras_dl = -sigma2(i) * mort_P(i) * sr
     
     sr       = fA*fR + mort_R(i)/(prod+eps) + 0.
     if(sr .lt. 1.0d0) then
       prod_dl  = sigma2(i) * self%yield*yfac * (1.0d0 - sr) * dprod_dl(i)
     else
       prod_dl  = 0.0d0
     endif
!     resp_dl  = 0.0d0     prod_dl  = 0.0d0
!  sum of productivity related size selective forces
     sum_dl   = init_dl + som_dl + prod_dl + resp_dl 
!***!
     if (.true.) then
! boundary condition of offspring production and adaptive size shift
      argA     = (self%l0-lmsize(i))/(sqrt(2.d0)*sig(i))
      min_dl   = -recruit * exp(argA**2) * sig(i) / sqrt(2.d0*3.1415)
      if (sum_dl .lt. min_dl ) then 
        bound_dl = min_dl-sum_dl
      else
        bound_dl = 0.0
      endif
      sum_dl   = sum_dl + bound_dl
     endif

 !  sum of all size selective forces
     sum_dl  = sum_dl + graz_dl + sen_dl +  turb_dl + paras_dl
   else
     sum_dl  = 0.0d0
   endif

!#S__RHS
!#E__RHS
!---------- RHS for each state variable ----------
   if (i .eq. 1) then ! Beroe
! --- dynamics of Beroe biomass
! quadratic mortality of Beroe to emulate top-down closure
 !   bcrit     = Temp_dep(3)*self%m_predBe* var(ib)%B_Be! * 3E-6 *var(ib)%ParasPp! 0.44**2/
!    rhsv%B_Be = (prod - mort_sum - bcrit)* var(ib)%B_Be + Temp_dep(1)*self%immigr
    rhsv%B_Be = (prod - mort_sum )* var(ib)%B_Be + Temp_dep(1)*self%immigr
! --- dynamics of Beroe mean log size
!  immigration  of mature individuals only
!    sum_dl  = sum_dl  + Temp_dep(1)*self%immigr*(self%lA+0.0-lmsize(i))/(var(ib)%B_Be+eps)
    rhsv%l_Be = sum_dl 

   ! Export diagnostic variables
    if (ib.eq.1) then

  _SET_DIAGNOSTIC_(self%id_prod_Be, prod)                   !step_integrated secondary production rate Beroe
  _SET_DIAGNOSTIC_(self%id_Mort_Be, mort_sum)               !step_integrated mortality rate of Beroe
  _SET_DIAGNOSTIC_(self%id_fA_Be, fA)                       !step_integrated relative propotion adults Beroe
  _SET_DIAGNOSTIC_(self%id_Imax_Be, Imax(1))        !step_integrated maximum ingestion rate adult Beroe
  _SET_DIAGNOSTIC_(self%id_al_Im, fLc(i))              !step_integrated size scaling expoentent Imax 

    endif

   else  !  P.Pileus
! --- dynamics of P.Pileus biomass
    rhsv%B_Pp = (prod - mort_sum) * var(ib)%B_Pp + Temp_dep(2)*self%immigr
! --- dynamics of P.Pileus mean log size
    rhsv%l_Pp = sum_dl 

! Export diagnostic variables
    if (ib.eq.1) then
  _SET_DIAGNOSTIC_(self%id_prod_Pp, prod)                   !step_integrated secondary production rate P pileus
  _SET_DIAGNOSTIC_(self%id_Mort_Pp, mort_sum)               !step_integrated mortality rate of P pileus
  _SET_DIAGNOSTIC_(self%id_fA_Pp, fA)                       !step_integrated relative propotion adults P pileus
  _SET_DIAGNOSTIC_(self%id_Imax_Pp, Imax(2))                !step_integrated maximum ingestion rate adult Beroe
  _SET_DIAGNOSTIC_(self%id_lopt_Be, lopt(1))                !step_integrated optimum prey size Beroe
  _SET_DIAGNOSTIC_(self%id_som_dl, som_dl)                  !step_integrated marginal size shift due to promotion
  _SET_DIAGNOSTIC_(self%id_init_dl, init_dl)                !step_integrated marginal size shift due to egg production
  _SET_DIAGNOSTIC_(self%id_graz_dl, graz_dl)                !step_integrated marginal size shift due to selective grazing
  _SET_DIAGNOSTIC_(self%id_sen_dl, sen_dl)                  !step_integrated marginal size shift due to starvation 
  _SET_DIAGNOSTIC_(self%id_turb_dl, cnid)                  !step_integrated marginal size shift due to physical damage 
  _SET_DIAGNOSTIC_(self%id_prod_dl, prod_dl)                !step_integrated marginal size shift due to production 
  _SET_DIAGNOSTIC_(self%id_resp_dl, resp_dl)                !step_integrated marginal size shift due to respiration 
  _SET_DIAGNOSTIC_(self%id_paras_dl, paras_dl)              !step_integrated marginal size shift due to parasitism 
  _SET_DIAGNOSTIC_(self%id_dl_prey, dg_dly(i))                !step_integrated size difference to prey 
  _SET_DIAGNOSTIC_(self%id_dl_pred, dprod_dl(i))                 !step_integrated size difference to pred 
  _SET_DIAGNOSTIC_(self%id_mort_P, mort_P(i))                  !step_integrated density dependent mortality - parasites
  _SET_DIAGNOSTIC_(self%id_mort_S, reltim)                  !step_integrated physiological adult mortality rate
  _SET_DIAGNOSTIC_(self%id_mort_R, mort_R(i))                  !step_integrated temperature dependent mortality
  _SET_DIAGNOSTIC_(self%id_mort_G, mGrz(i))                  !step_integrated top-predation
  _SET_DIAGNOSTIC_(self%id_mort_J, mben)                  !step_integrated juvenile mortality
  _SET_DIAGNOSTIC_(self%id_mort_T, mort_top)                !step_integrated damaging effect of turbulence 
  _SET_DIAGNOSTIC_(self%id_somgrowth, somgrwth)             !step_integrated somatic growth rate 
  _SET_DIAGNOSTIC_(self%id_recruit, mass3)                !recruitstep_integrated egg production rate 
  _SET_DIAGNOSTIC_(self%id_mixBmass,m_host(i))            !step_integrated mass exchange rate Coast-HR-Offshore 
  _SET_DIAGNOSTIC_(self%id_mixlsize, mass(3))           !dTrait(2,1)step_integrated trait exchange rate Coast-HR-Offshore
  _SET_DIAGNOSTIC_(self%id_Tdep, Temp_dep(i))                  !step_integrated Temperature dependence
    endif
  endif
!write (*,'(1(F10.6))')   ftd/ntd 
!#S__DIA
!#E__DIA
  end do
! ------------------------------------------------------------------------------
!#S_ODE
!---------- ODE for each state variable ----------
  _SET_ODE_(self%id_B_Pp, rhsv%B_Pp UNIT)
  _SET_ODE_(self%id_l_Pp, rhsv%l_Pp UNIT)
  _SET_ODE_(self%id_B_Be, rhsv%B_Be UNIT)
  _SET_ODE_(self%id_l_Be, rhsv%l_Be UNIT)
  _SET_ODE_(self%id_B_Det, rhsv%B_Det UNIT)
  _SET_ODE_(self%id_ParasPp, rhsv%ParasPp UNIT)
  _SET_ODE_(self%id_ParasBe, rhsv%ParasBe UNIT)
  _SET_ODE_(self%id_BenTime, rhsv%BenTime UNIT)
!#E_ODE
  end do
   ! Leave spatial loops (if any)
   _FABM_LOOP_END_

   end subroutine do
!EOC

! ------------------------------------------------------------------------------
  pure real(rk) function grazkinetics(bcrit,preye)
   implicit none
   real(rk), intent(in)      :: bcrit, preye

   grazkinetics = 1.0d0-exp(-preye/bcrit)
   end function grazkinetics

! ------------------------------------------------------------------------------
! effective prey after integration over selection kernel  (Wirtz, MEPS 2014)
  pure real(rk) function prey_effc(dl2)
   implicit none
   real(rk), intent(in)      :: dl2
   prey_effc     = sqrt(i13sig) * exp(-dl2*i13sig)
   end function prey_effc

! ------------------------------------------------------------------------------
  pure real(rk) function grazrate(dl2,Imax0, bcrit, prey)
   implicit none
   real(rk), intent(in)      :: dl2, Imax0, bcrit, prey
 !   real(rk)   :: dl2
   grazrate = Imax0  * exp(-dl2) * grazkinetics(bcrit,prey) 

   end function grazrate

! ------------------------------------------------------------------------------
  pure real(rk) function f_temp(q10,T,T_c)
   implicit none
   real(rk), intent(in)      :: q10,T,T_c
!  real(rk)   :: q2
!   q2      = q10**2
!   f_temp  = 1.0d0/(q2 * exp(-T*q10/30)+ exp(-q2*(T-T_c)))
   f_temp  = 1.0d0/(exp(-(T-15.0d0)*0.1*log(q10))+ exp(-exp(1+q10)*(T-T_c)*0.1) )

   end function f_temp

! ------------------------------------------------------------------------------
  pure real(rk) function e_temp(T,T_c)
   implicit none
   real(rk), intent(in)      :: T,T_c
   real(rk) par
   e_temp  = 1.0d0/(1.0d0+ exp((T-T_c)/2+1.0d0) )
!   e_temp  = exp(-T**2/(2*T_c**2))
!   e_temp  = 0.1d0 + 0.9d0/(1.0d0+ exp(1*(T-T_c)) )

 !0.1+0.9./(1+exp(2*(T-T_c)));
   end function e_temp

! ------------------------------------------------------------------------------
subroutine mixing(self,Dil,Conci,Volo,Conco, dConci, dConco)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: Dil,Conci,Volo,Conco
 real(rk), intent(inout)   :: dConci, dConco
 real(rk)   ::  Conc_mix
! mixing coefficients 
 Conc_mix = (Conco*Volo+Conci)/(Volo + 1.0d0)
 
 dConci = Dil* ( Conco - Conc_mix ) *  Volo
 dConco = Dil* ( Conci - Conc_mix ) 
end subroutine mixing

subroutine errfunc(self,arg,errf)
implicit none
! !INPUT PARAMETERS:
 class (type_hzg_jelly),intent(in) :: self
 real(rk), intent(in)      :: arg
 real(rk), intent(inout)   :: errf
 real(rk)   :: art

 errf  = (1-exp(-arg*2.45d0))/(1+exp(-arg*2.45d0))

end subroutine errfunc

!EOC
end module hzg_jelly
!:#endif
